import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { resolveWorkspaceId } from "@/lib/auth-server";
import { generateInsightFromMessage } from "@/lib/ai/persona-insight-generator";

// ─── GET /api/personas/[id]/chat/[sessionId]/insights ────────
// List all insights for a session
// ──────────────────────────────────────────────────────────────
export async function GET(
  _request: NextRequest,
  { params }: { params: Promise<{ id: string; sessionId: string }> }
) {
  try {
    const workspaceId = await resolveWorkspaceId();
    if (!workspaceId) {
      return NextResponse.json({ error: "No workspace found" }, { status: 403 });
    }

    const { id, sessionId } = await params;

    // Verify session belongs to this persona and workspace
    const chatSession = await prisma.personaChatSession.findFirst({
      where: { id: sessionId, personaId: id, workspaceId },
    });

    if (!chatSession) {
      return NextResponse.json({ error: "Chat session not found" }, { status: 404 });
    }

    const insights = await prisma.personaChatInsight.findMany({
      where: { sessionId },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({
      insights: insights.map((i) => ({
        id: i.id,
        sessionId: i.sessionId,
        messageId: i.messageId,
        type: i.type,
        title: i.title,
        content: i.content,
        severity: i.severity,
        isAutoGenerated: i.isAutoGenerated,
        createdAt: i.createdAt.toISOString(),
      })),
    });
  } catch (error) {
    console.error("[GET /api/personas/:id/chat/:sessionId/insights]", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

// ─── POST /api/personas/[id]/chat/[sessionId]/insights ───────
// Generate an insight from a specific message using LLM
// ──────────────────────────────────────────────────────────────
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; sessionId: string }> }
) {
  try {
    const workspaceId = await resolveWorkspaceId();
    if (!workspaceId) {
      return NextResponse.json({ error: "No workspace found" }, { status: 403 });
    }

    const { id: personaId, sessionId } = await params;

    // Verify session
    const chatSession = await prisma.personaChatSession.findFirst({
      where: { id: sessionId, personaId, workspaceId },
    });
    if (!chatSession) {
      return NextResponse.json({ error: "Chat session not found" }, { status: 404 });
    }

    const body = await request.json();
    const { messageId } = body;

    if (!messageId || typeof messageId !== "string") {
      return NextResponse.json(
        { error: "messageId is required" },
        { status: 400 }
      );
    }

    // Verify the message exists and is an ASSISTANT message
    const targetMessage = await prisma.personaChatMessage.findFirst({
      where: { id: messageId, sessionId, role: "ASSISTANT" },
    });
    if (!targetMessage) {
      return NextResponse.json(
        { error: "Assistant message not found" },
        { status: 404 }
      );
    }

    // Check if insight already exists for this message
    const existingInsight = await prisma.personaChatInsight.findFirst({
      where: { messageId, sessionId },
    });
    if (existingInsight) {
      return NextResponse.json(
        { error: "Insight already generated for this message" },
        { status: 409 }
      );
    }

    // Get context: 1 message before + 1 message after the target
    const allMessages = await prisma.personaChatMessage.findMany({
      where: { sessionId },
      orderBy: { createdAt: "asc" },
      select: { id: true, role: true, content: true },
    });

    const targetIndex = allMessages.findIndex((m) => m.id === messageId);
    const contextMessages: { role: string; content: string }[] = [];

    // 1 message before
    if (targetIndex > 0) {
      const prev = allMessages[targetIndex - 1];
      contextMessages.push({ role: prev.role, content: prev.content });
    }
    // 1 message after
    if (targetIndex < allMessages.length - 1) {
      const next = allMessages[targetIndex + 1];
      contextMessages.push({ role: next.role, content: next.content });
    }

    // Load chat config for LLM settings
    const chatConfig = await prisma.personaChatConfig.findUnique({
      where: { workspaceId },
    });

    const provider = chatConfig?.provider || "anthropic";
    const model = chatConfig?.model || "claude-sonnet-4-20250514";

    // Call LLM to extract insight
    const extracted = await generateInsightFromMessage({
      contextMessages,
      targetMessage: targetMessage.content,
      provider,
      model,
    });

    // Save insight to database
    const insight = await prisma.personaChatInsight.create({
      data: {
        sessionId,
        messageId,
        type: extracted.type,
        title: extracted.title,
        content: extracted.content,
        severity: extracted.severity,
        isAutoGenerated: false, // User-triggered via lightbulb button
      },
    });

    return NextResponse.json({
      id: insight.id,
      sessionId: insight.sessionId,
      messageId: insight.messageId,
      type: insight.type,
      title: insight.title,
      content: insight.content,
      severity: insight.severity,
      isAutoGenerated: insight.isAutoGenerated,
      createdAt: insight.createdAt.toISOString(),
    }, { status: 201 });
  } catch (error) {
    console.error("[POST /api/personas/:id/chat/:sessionId/insights]", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

// ─── DELETE /api/personas/[id]/chat/[sessionId]/insights ─────
// Delete a specific insight by ID (passed as query param ?insightId=xxx)
// ──────────────────────────────────────────────────────────────
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; sessionId: string }> }
) {
  try {
    const workspaceId = await resolveWorkspaceId();
    if (!workspaceId) {
      return NextResponse.json({ error: "No workspace found" }, { status: 403 });
    }

    const { id: personaId, sessionId } = await params;

    // Verify session
    const chatSession = await prisma.personaChatSession.findFirst({
      where: { id: sessionId, personaId, workspaceId },
    });
    if (!chatSession) {
      return NextResponse.json({ error: "Chat session not found" }, { status: 404 });
    }

    const insightId = request.nextUrl.searchParams.get("insightId");
    if (!insightId) {
      return NextResponse.json(
        { error: "insightId query param is required" },
        { status: 400 }
      );
    }

    // Verify insight exists in this session
    const insight = await prisma.personaChatInsight.findFirst({
      where: { id: insightId, sessionId },
    });
    if (!insight) {
      return NextResponse.json({ error: "Insight not found" }, { status: 404 });
    }

    await prisma.personaChatInsight.delete({
      where: { id: insightId },
    });

    return NextResponse.json({ deleted: true });
  } catch (error) {
    console.error("[DELETE /api/personas/:id/chat/:sessionId/insights]", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
